"""
Event types for the trading system's event-driven architecture.
Immutable dataclasses ensure thread safety and prevent accidental mutation.
"""
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Optional, Dict, Any
import uuid


@dataclass(frozen=True)
class Event:
    """
    Base event class with universal properties.
    All events are immutable (frozen) for thread safety.
    """
    event_id: str = field(default_factory=lambda: f"evt_{uuid.uuid4().hex[:12]}")
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    event_type: str = "EVENT"
    
    def __post_init__(self):
        # Ensure timezone-aware UTC timestamps
        if self.timestamp.tzinfo is None:
            object.__setattr__(self, 'timestamp', self.timestamp.replace(tzinfo=timezone.utc))
        elif self.timestamp.tzinfo != timezone.utc:
            object.__setattr__(self, 'timestamp', self.timestamp.astimezone(timezone.utc))


@dataclass(frozen=True)
class CandleEvent(Event):
    """
    Represents a completed candle (OHLCV) for a specific instrument/timeframe.
    
    Critical Design:
      - Only emitted AFTER candle completes (no repainting risk)
      - Contains raw price data + metadata for strategy context
      - Immutable to prevent accidental modification during propagation
    """
    symbol: str = ""
    timeframe: str = "M1"  # OANDA granularity (M1, M5, H1, etc.)
    open: float = 0.0
    high: float = 0.0
    low: float = 0.0
    close: float = 0.0
    volume: int = 0
    complete: bool = True  # Always True for emitted events (incomplete candles filtered upstream)
    
    def __post_init__(self):
        super().__post_init__()
        object.__setattr__(self, 'event_type', 'CANDLE')
        
        # Validate required fields
        if not self.symbol:
            raise ValueError("CandleEvent requires symbol")
        if self.open <= 0 or self.high <= 0 or self.low <= 0 or self.close <= 0:
            raise ValueError(f"Invalid OHLC prices: O={self.open}, H={self.high}, L={self.low}, C={self.close}")
        if self.high < max(self.open, self.close, self.low):
            raise ValueError(f"Invalid high price: {self.high} < max(O={self.open}, C={self.close}, L={self.low})")
        if self.low > min(self.open, self.close, self.high):
            raise ValueError(f"Invalid low price: {self.low} > min(O={self.open}, C={self.close}, H={self.high})")


@dataclass(frozen=True)
class SignalEvent(Event):
    """
    Represents a trading signal generated by a strategy.
    
    Critical Design:
      - Direction: +1 (long/buy), -1 (short/sell), 0 (flat/close)
      - Price: Entry price for the signal (typically candle close)
      - Metadata: Strategy-specific context for execution/risk management
      - Immutable to ensure signal integrity from generation to execution
    """
    symbol: str = ""
    direction: int = 0  # +1 = buy/long, -1 = sell/short, 0 = close/flat
    price: float = 0.0
    strategy_name: str = ""
    timeframe: str = ""  # Timeframe that generated the signal
    meta: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        super().__post_init__()
        object.__setattr__(self, 'event_type', 'SIGNAL')
        
        # Validate required fields
        if not self.symbol:
            raise ValueError("SignalEvent requires symbol")
        if self.direction not in (-1, 0, 1):
            raise ValueError(f"Invalid direction: {self.direction} (must be -1, 0, or 1)")
        if self.price <= 0:
            raise ValueError(f"Invalid signal price: {self.price}")
        if not self.strategy_name:
            raise ValueError("SignalEvent requires strategy_name")


@dataclass(frozen=True)
class OrderEvent(Event):
    """
    Represents an order to be executed (paper/live trading).
    Generated by PortfolioManager after signal validation.
    """
    symbol: str = ""
    order_type: str = "MARKET"  # MARKET, LIMIT, STOP
    direction: int = 0  # +1 = buy, -1 = sell
    units: float = 0.0
    price: Optional[float] = None  # For limit/stop orders
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    meta: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        super().__post_init__()
        object.__setattr__(self, 'event_type', 'ORDER')
        
        if not self.symbol:
            raise ValueError("OrderEvent requires symbol")
        if self.order_type not in ("MARKET", "LIMIT", "STOP"):
            raise ValueError(f"Invalid order_type: {self.order_type}")
        if self.direction not in (-1, 1):
            raise ValueError(f"Invalid order direction: {self.direction} (must be -1 or 1)")
        if self.units <= 0:
            raise ValueError(f"Invalid order units: {self.units}")


@dataclass(frozen=True)
class FillEvent(Event):
    """
    Represents a completed order fill (execution confirmation).
    Generated by ExecutionHandler after broker confirmation.
    """
    symbol: str = ""
    direction: int = 0
    units: float = 0.0
    price: float = 0.0
    commission: float = 0.0
    order_id: str = ""
    meta: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        super().__post_init__()
        object.__setattr__(self, 'event_type', 'FILL')
        
        if not self.symbol:
            raise ValueError("FillEvent requires symbol")
        if self.direction not in (-1, 1):
            raise ValueError(f"Invalid fill direction: {self.direction}")
        if self.units <= 0:
            raise ValueError(f"Invalid fill units: {self.units}")
        if self.price <= 0:
            raise ValueError(f"Invalid fill price: {self.price}")


# Event type registry for validation/routing
EVENT_TYPES = {
    'CANDLE': CandleEvent,
    'SIGNAL': SignalEvent,
    'ORDER': OrderEvent,
    'FILL': FillEvent
}


def create_candle_event(
    symbol: str,
    timeframe: str,
    open: float,
    high: float,
    low: float,
    close: float,
    volume: int = 0,
    timestamp: Optional[datetime] = None,
    complete: bool = True
) -> CandleEvent:
    """Factory function for creating CandleEvents with proper defaults."""
    return CandleEvent(
        symbol=symbol,
        timeframe=timeframe,
        open=open,
        high=high,
        low=low,
        close=close,
        volume=volume,
        complete=complete,
        timestamp=timestamp if timestamp else datetime.now(timezone.utc)
    )

def create_signal_event(
    symbol: str,
    direction: int,
    price: float,
    strategy_name: str,
    timeframe: str = "",
    meta: Optional[Dict[str, Any]] = None,  # ← CORRECT PARAM NAME: "meta" not "metadata"
    timestamp: Optional[datetime] = None
) -> SignalEvent:
    """Factory function for creating SignalEvents with proper defaults."""
    return SignalEvent(
        symbol=symbol,
        direction=direction,
        price=price,
        strategy_name=strategy_name,
        timeframe=timeframe,
        meta=meta or {},  # ← PASS TO "meta" FIELD
        timestamp=timestamp if timestamp else datetime.now(timezone.utc)
    )